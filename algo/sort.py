# 判断一个排序算法的好坏，一般有以下几个指标：
# 时间复杂度：排序算法的时间复杂度是衡量其好坏的一个重要指标，通常用大O符号表示。时间复杂度越小，算法的效率越高。
# 空间复杂度：排序算法的空间复杂度是衡量其好坏的另一个指标，通常也用大O符号表示。空间复杂度越小，算法所需的内存越少。
# 稳定性：如果排序算法能够保持相等元素的相对位置不变，就称该算法是稳定的。稳定性是排序算法好坏的一个重要指标，因为在某些场景下需要保持相等元素的相对位置不变。
# 适用性：不同的排序算法适用于不同的场景，具有不同的优缺点。因此，在选择排序算法时，需要考虑数据规模、数据类型、数据分布等因素，选择适合的算法。
# 实现难度：排序算法的实现难度也是一个指标。实现难度较大的算法可能需要更多的时间和精力，但也可能具有更好的性能。
# 综上所述，判断一个排序算法的好坏需要考虑多个因素，需要根据具体场景进行评估和选择。


# 快速排序是稳定的排序算法吗？
# 一般情况下，快速排序不是稳定的排序算法。因为快速排序的过程中涉及到元素的交换，这可能会破坏相等元素的相对位置。例如，一个数组中存在多个相等元素，当以其中一个相等元素作为基准值进行分割时，其他相等元素可能会被分配到基准值的左侧或右侧，从而导致它们的相对位置发生变化。
# 然而，在某些特殊情况下，快速排序也可以是稳定的。例如，当快速排序的实现方式采用了“三路快排”或“双轴快排”等特殊技巧时，就可以保证排序的稳定性。这些技巧可以避免元素的交换，而是通过将数组分成多个区域进行排序，从而保持相等元素的相对位置不变。
# 综上所述，一般情况下快速排序不是稳定的排序算法，但在某些特殊情况下可以通过特殊技巧实现排序的稳定性。


# 快速排序实现1
# 它的基本思想是通过一趟排序将待排序的数据分割成独立的两部分，其中一部分的所有元素都比另一部分的元素要小，然后再按此方法对这两部分数据分别进行快速排序，整个过程可以递归进行，以达到整个数据变成有序序列的目的。
# 快速排序的时间复杂度为O(nlogn)，在大规模数据的排序中表现优异

def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    else:
        pivot = arr[0] # 选择数组的第一个元素作为基准值
        left = []
        right = []
        for i in arr[1:]:
            if i < pivot:
                left.append(i)
            else:
                right.append(i)
        return quick_sort(left) + [pivot] + quick_sort(right)


# 三路快排实现：是一种基于快速排序算法的改进算法，可以在保证快速排序的时间复杂度O(nlogn)的同时，解决重复元素的问题，保证排序的稳定性。以下是使用Python实现的三路快排算法：
# 下面实现过程中，将数组分成三个部分，小于基准值的元素放在left中，等于基准值的元素放在mid中，大于基准值的元素放在right中。然后对left和right继续递归调用快速排序算法，最后将三部分的结果合并起来即可。
# 由于三路快排将数组分成三个部分，保留了重复元素的相对顺序，因此可以保证排序的稳定性。
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    else:
        pivot = arr[0] # 选择数组的第一个元素作为基准值
        left = []
        mid = []
        right = []
        for i in arr:
            if i < pivot:
                left.append(i)
            elif i > pivot:
                right.append(i)
            else:
                mid.append(i)
        return quick_sort(left) + mid + quick_sort(right)
    


# 插入排序是一种简单直观的排序算法，它的实现思路如下：
# 遍历待排序的数组，从第二个元素开始。
# 将当前元素插入到前面已经排好序的子数组中，使得插入后仍然保持有序。
# 重复执行步骤2，直到所有元素都被插入到有序子数组中，排序完成。
# 具体实现过程中，可以使用一个for循环遍历待排序数组，从第二个元素开始（索引为1），将当前元素保存到一个变量key中。然后再使用一个while循环依次比较key和它前面的元素，如果前面的元素比key大，就将前面的元素后移一位，直到找到第一个比key小的元素或者已经比较到数组的第一个元素。然后将key插入到找到的位置之后，即在arr[j+1]的位置上。
# 以上就是插入排序的实现思路，它的时间复杂度为O(n^2)，但在实际应用中通常表现良好。
def insertion_sort(arr):
    n = len(arr)
    for i in range(1, n):
        key = arr[i]
        j = i-1
        while j >=0 and key < arr[j] :
                arr[j+1] = arr[j]
                j -= 1
        arr[j+1] = key
    return arr

arr = [4,2,6,77,4,32,1,6,9,6,5,3,4,2,1]
print(insertion_sort(arr))